// 1. 项目概述
// 1.1 背景
// Unity 项目开发中，会长期积累大量美术资源（模型、动画、贴图、图片、声音、特效等）。常见痛点：

// 资源分散在不同工程和磁盘文件夹中，不易整理；
// 查找素材/参考时，需要频繁打开文件夹、导入工程、逐个检查，耗时低效；
// 团队内部共享素材不便，经常通过压缩包、网盘、不统一路径传来传去，重复下载、重复制作。
// 1.2 目标
// 构建一个基于 Unity 6.2 的 独立 Windows 客户端应用，配合一个 局域网服务器，形成 C/S 模式的美术资源管理系统：

// 单机使用：个人可以将素材统一整理到一个本地或网络 Library 中，便于浏览、预览、搜索和导出。
// 局域网共享：在同一局域网内，多台客户端可连接同一个服务器：
// 集中管理一个“中央资源库”；
// 多人共享上传、浏览、导出素材；
// 通过简单权限控制限制删除/修改等高危操作。
// 1.3 运行形态
// 客户端（Client）
// Unity 6.2 打包为 Windows EXE；
// 提供 UI、预览、搜索等功能；
// 本地只缓存必要的缩略图与少量元数据，资源的“真身”在服务器。
// 服务器（Server）
// 使用 .NET（C#）实现一个轻量 HTTP REST API 服务；
// 可选：采用 Unity + HttpListener 或纯 .NET 控制台程序；
// 管理中央资源库（LibraryRoot 目录）及所有元数据和实际文件；
// 负责统一收发客户端的上传/下载/管理请求。
// 2. 功能需求（客户端 + 服务器）
// 2.1 基本资源管理（与单机一致的核心能力）
// 以下功能在“单机模式”和“局域网模式”下逻辑相同，只是数据来源不同（本地 / 服务器）：

// 资源分类与浏览；
// 标签系统与搜索/过滤；
// 模型预览（线框/无材质/有材质、面数统计、动画播放）；
// 上传/导入资源；
// 资源管理（修改信息、更新文件、版本管理、删除）；
// Library 根目录管理（服务器端）；
// 导出资源（客户端从服务器下载后导出到本地）。
// 下文会先描述这些核心功能，然后描述局域网共享相关的新增功能。

// 2.2 资源分类与浏览（客户端）
// 需求描述：

// 按资源类型分类：
// 模型（Model，可以给模型赋予贴图、动画）
// 图片（Texture）
// 声音（Sound）
// 特效（VFX / Prefab）
// 客户端主界面左侧提供分类导航：
// 全部
// 模型
// 图片
// 声音
// 特效
// 最近使用
// 收藏（可选）
// 中部资源列表：
// 列表/网格模式；
// 显示缩略图、名称、类型、常用标签、时间信息。
// 右侧详情 + 预览区域，点击列表项后展示。
// 局域网说明：

// 当客户端连接到服务器时：
// 列表数据通过 REST API 从服务器获取；
// 不再扫描本地 LibraryRoot（除非在“单机模式”下运行）。
// 服务端负责将资源列表分页/过滤后返回给客户端。
// 2.3 标签系统与搜索/过滤（客户端）
// 需求描述：

// 每个资源可有多个标签（Tag）。
// 客户端可在详情中编辑标签：
// 新增、删除；
// 上传时设定初始标签。
// 支持：
// 按标签过滤；
// 名称搜索；
// 综合搜索（名称 + 标签 + 描述）。
// 支持多标签筛选（包含所有选择的标签）。
// 局域网说明：

// 标签增删修改通过客户端发起 HTTP 请求，由服务器更新该资源 meta；
// 搜索/过滤可分两种策略：
// 简单版：客户端拉取一定范围的资源列表，再在本地过滤；
// 完善版：支持在 API 请求中传入 type/name/tags 参数，由服务器端在索引上过滤后返回结果。
// 2.4 模型预览与信息显示（客户端）
// 需求描述：

// 对模型资源，客户端提供 3D 预览：
// 支持旋转、缩放、平移；
// 支持线框 / 无材质 / 有材质模式；
// 显示面数（三角数）、Mesh 数量；
// 显示动画 Clip 列表并可播放。
// 模型信息（面数、是否有动画、Clip 名称等）由服务器在资源导入时预处理并写入 meta，客户端直接读取展示即可。
// 模型预览加载流程：
// 客户端请求下载模型文件（如果本地没有缓存或缓存已失效）；
// 使用运行时模型加载库（如 TriLib2）在客户端内存中加载；
// 将模型实例放入客户端的 PreviewScene 中渲染。
// 局域网说明：

// 模型文件存储在服务器的中央 Library 目录；
// 客户端通过 GET /api/assets/{id}/file 接口下载；
// 建议客户端对下载的模型采用本地缓存（例如在 %LOCALAPPDATA%/AssetManagerCache/ 目录下），通过资源 ID + 文件 Hash 做缓存命名。
// 2.5 上传 / 导入资源（客户端 → 服务器）
// 需求描述：

// 在客户端有上传界面：
// 选择本地文件（支持多选）；
// 选择资源类型（可自动识别后手动修改）；
// 输入名称、标签、描述等信息。
// 上传时，客户端通过 HTTP 向服务器发送：
// 元信息（JSON：名称、类型、标签等）；
// 实际文件数据（表单上传 / 分块上传）。
// 服务器接收后：
// 把文件存入中央 Library 目录；
// 生成/更新该资源的 meta（包括面数、缩略图等，可同步或异步生成）；
// 将成功创建的资源对象返回给客户端。
// 局域网补充：

// 上传接口格式初版可采用 multipart/form-data：
// POST /api/assets
// 表单字段：metadata（JSON 字符串）、file（二进制）。
// 服务器需支持简单的权限控制：
// 未登录或普通用户是否允许上传：可配置；
// 管理员权限可上传并修改其他资源。
// 2.6 资源管理（修改、版本、删除）
// 需求描述：

// 修改资源信息：
// 名称、标签、描述；
// 由客户端界面提交更改，调用 PUT /api/assets/{id}。
// 更新资源文件：
// 为已有资源上传一个新文件版本；
// 可选择是否“新版本”或“覆盖当前版本”；
// 服务器负责版本文件存储与记录。
// 删除资源：
// 调用 DELETE /api/assets/{id}；
// 需要管理员权限；
// 支持删除当前版本或所有版本（按后端策略）。
// 局域网补充：

// 管理操作统一通过服务器 API 完成；
// 客户端只操作 UI 和发送请求，不直接修改中央 Library 的磁盘结构；
// 客户端本地的缓存文件可在资源删除后清理（可延后处理）。
// 2.7 Library 根目录管理（服务器）
// 需求描述：

// 服务器端配置一个中央 Library 根目录，例如：

// text
// D:/SharedAssetLibrary/
//   Models/
//   Textures/
//   Sounds/
//   VFX/
//   config.json
//   index.json
// 服务器启动时：

// 读取配置文件（如 server_config.json）获得 LibraryRoot；
// 若不存在则创建基础目录结构；
// 扫描或加载 index.json 建立内存索引。
// 客户端无权直接修改服务器的 LibraryRoot，只能通过管理员在服务器配置文件中调整，并重启服务器生效。

// 单机模式说明：

// 若客户端不连接任何服务器，可以选择本地某路径作为“本地 Library”（类似原单机版）；
// 这部分实现可以与服务器端逻辑共享一套 LibraryManager 核心代码，只是运行位置不同。
// 2.8 导出资源（客户端）
// 需求描述：

// 用户在客户端勾选一个或多个资源；
// 选择“导出”：
// 选择本机导出目录；
// 可选择“连同依赖贴图一起导出”；
// 客户端对每个资源：
// 调用 GET /api/assets/{id}/file 下载主文件（如果本地无缓存）；
// 根据服务器 meta 中记录的依赖信息（如贴图路径等），逐个拉取；
// 将文件复制到本地目标目录，形成清晰的导出结构；
// 可导出 meta 信息作为描述文件。
// 2.9 缩略图与快速预览（服务器 + 客户端）
// 服务器职责：

// 导入/更新资源后：

// 对模型和特效，在服务器端用 Unity（或自写工具）进行一次离线生成缩略图：
// 启动一个 Hidden Unity 实例或独立工具执行生成（具体实现可按团队资源选择，第一版也可以在首次客户端请求时由客户端生成再上传回服务器）。
// 对图片直接缩放生成；
// 对声音使用统一 icon。
// 缩略图保存在服务器 Library 中：

// text
// Models/asset1/asset1_thumbnail.png
// Textures/asset2/asset2_thumbnail.png
// ...
// 提供接口：

// GET /api/assets/{id}/thumbnail 返回缩略图文件。
// 客户端职责：

// 列表中显示缩略图：
// 优先从本地缓存读取；
// 若缓存不存在则从服务器拉取并保存到客户端缓存目录。
// 预览信息（名称、类型、标签、时间、面数、动画等）由客户端通过 GET /api/assets/{id} 拉取 meta 展示。
// 2.10 搜索与过滤（服务器支持 / 客户端增强）
// API 设计建议：

// GET /api/assets?type=Model&name=rock&tags=stone,scifi&page=1&pageSize=50
// 行为：

// 服务端根据查询参数在内存索引（或数据库）中进行过滤；
// 返回分页结果（总数、当前页数据）；
// 客户端只需把列表展示出来，再次筛选可在本地做轻量过滤。
// 2.11 批量操作（客户端）
// 需求描述：

// 多选资源后可执行：
// 批量添加标签；
// 批量删除某个标签；
// 批量导出。
// 批量操作的实际修改行为：
// 对每个资源调用相应的服务器 API（可批量 API，也可循环调用单个 API）；
// 客户端负责执行进度显示。
// 2.12 重复资源检测（服务器）
// 需求描述：

// 服务器在接收上传文件后：
// 计算文件 Hash（如 SHA1）；
// 查找索引中是否有相同 Hash 的资源；
// 若存在重复：
// 服务器在 API 响应中标记状态（如 isDuplicate = true，并返回已存在资源的简要列表）；
// 客户端据此弹出交互：
// 作为新资源继续创建；
// 作为已有资源的新版本；
// 或者取消。
// 实际重复处理逻辑在服务器侧执行，确保所有客户端都遵守统一规则。
// 2.13 简易版本管理（服务器）
// 需求描述：

// 服务器为每个资源维护版本列表（meta 中的 versions）。
// 当客户端发起“更新资源文件”请求：
// PUT /api/assets/{id}/file?createNewVersion=true；
// 服务器将当前文件移动到 Versions/ 子目录；
// 新文件存为当前版本文件；
// 更新 meta 中的当前版本和版本历史。
// 客户端在详情界面可以看到版本列表（由 API 返回）并支持“回退到某版本”操作：
// 用户操作 → 调 POST /api/assets/{id}/revert?version=X；
// 服务器负责切换文件并更新 meta。
// 2.14 性能与大库处理（服务器 + 客户端）
// 服务器侧：

// 维护内存索引：
// ID → 资源；
// Tag → 资源列表；
// Hash → 资源列表；
// 类型 + 名称关键字索引；
// 提供分页接口，避免一次性返回几千条数据；
// 可为常用查询结果增加缓存。
// 客户端侧：

// 对列表采用虚拟化渲染 / 分页加载；
// 缩略图和模型文件采用本地缓存，减少重复网络流量；
// 后台线程或协程处理大文件下载，并展示进度条。
// 2.15 局域网共享与多客户端协同（新增重点）
// 此为新增的核心功能段。

// 2.15.1 C/S 架构概述
// 服务器端（Server）
// 运行在局域网任意一台机器上；
// 提供 HTTP REST API；
// 管理中央 Library 根目录；
// 负责所有资源的真实存储、元数据维护和并发访问控制。
// 客户端（Client）
// 运行在每个开发者本地电脑上；
// 用户在客户端中输入服务器地址（http://192.168.1.100:8080 等）；
// 通过 REST API 与服务器交互：
// 浏览资源、搜索；
// 上传新资源；
// 下载并导出资源；
// 修改标签、信息（视权限而定）。
// 2.15.2 通信协议与接口设计
// 通信协议：

// 使用 HTTP + JSON 的 REST API；
// 所有数据交互（除文件传输）都以 JSON 格式。
// 主要接口示例：

// 资源列表与详情：
// GET /api/assets?type=Model&name=rock&tags=stone&page=1&pageSize=50
// GET /api/assets/{id}
// 文件与缩略图：
// GET /api/assets/{id}/file （下载资源文件）
// GET /api/assets/{id}/thumbnail （获取缩略图）
// 创建/更新/删除：
// POST /api/assets （上传新资源，multipart/form-data）
// PUT /api/assets/{id} （更新元信息：名称、标签、描述等）
// PUT /api/assets/{id}/file （更新资源文件）
// DELETE /api/assets/{id} （删除资源）
// 版本管理：
// GET /api/assets/{id}/versions
// POST /api/assets/{id}/revert （回退到指定版本）
// 2.15.3 服务器端功能
// 资源管理：
// 统一建立和维护中央 Library 目录结构；
// 负责创建/写入/读取 meta.json；
// 负责文件存储、版本管理、缩略图生成（或协调客户端上报）。
// 客户端请求处理：
// 处理来自多个客户端的并发请求；
// 对写操作（上传、删除、更新）进行锁和冲突控制（防止同一资源在同一时刻被多次覆盖）。
// 索引与搜索：
// 在内存中维护索引以加速按名称、类型、标签、Hash 检索；
// 提供分页查询 API。
// 权限与简单安全：
// 提供简单的认证机制（选项）：
// 无认证模式（仅限局域网小团队使用）；
// 简单密码模式：
// 普通用户（浏览+下载+上传）；
// 管理员（增加删除/修改权限）。
// 认证方式可以使用：
// 简易 HTTP Header Token；
// 或非常简单的 query 参数 Token（局域网下可接受，但要在文档中明确风险）。
// 并发控制：
// 通过文件锁或互斥机制，防止同一 meta 文件被多个线程同时写入导致损坏；
// 对同一资源的版本更新和删除确保原子性。
// 2.15.4 客户端网络模块
// NetworkManager（客户端）职责：
// 维护服务器地址（http://ip:port）；
// 使用 UnityWebRequest 发送 HTTP 请求；
// 封装常用调用：
// GetAssets(...)
// GetAssetDetail(id)
// UploadAsset(...)
// DownloadFile(id, targetPath or stream) 等；
// 处理错误码（如 401 未授权、404 未找到、500 服务器异常），并在客户端 UI 显示提示。
// 连接与登录界面（客户端）：
// 简单输入框：
// 服务器地址（IP + 端口）；
// 可选密码/Token；
// 测试连接按钮：
// 调用 GET /api/ping 或 GET /api/version；
// 成功后保存配置。
// 与 UI 的关系：
// UI 控制器调用 NetworkManager 来获取远程数据和提交操作；
// UI 不直接操作本地 Library（除缓存和导出）。
// 2.15.5 权限模型
// 初版简化设计：

// 在服务器配置文件中配置两个密码（或 Token）：
// userToken：普通用户；
// adminToken：管理员。
// 客户端登录时用户选择角色：
// 输入对应 Token；
// 客户端在后续请求中将 Token 放在 HTTP Header 中（如 X-Auth-Token）。
// 权限规则：
// 普通用户：
// 浏览、搜索、下载、导出；
// 上传新资源（可选，配置决定）；
// 不允许删除和修改他人资源（可 configurable）。
// 管理员：
// 额外拥有：删除、修改、版本回退、批量管理等权限。
// 3. 非功能需求
// 稳定性：
// 客户端对服务器不可达、超时、返回错误等情况，要给出友好提示；
// 服务器对异常文件、并发写入等情况进行健壮处理。
// 可扩展性：
// 资源类型可扩展；
// 将来可以从局域网拓展到跨网络访问，只需换部署方式与安全策略。
// 性能：
// 支持上千条资源规模仍可流畅浏览、搜索；
// 网络请求分页、缓存缩略图与模型文件；
// 上传/下载大文件显示进度条。
// 安全性（局域网语境下）：
// 不做复杂加密，主要通过简单 Token 和局域网访问控制；
// 服务器提供可选的访问白名单/绑定网卡等配置。
// 4. 技术路线与选型
// 4.1 客户端（Unity EXE）
// 引擎：Unity 6.2
// UI：UI Toolkit (UXML + USS)
// 网络：UnityWebRequest（GET/POST/PUT/DELETE + 上传/下载）
// 模型加载预览：第三方运行时模型加载库（如 TriLib2）
// 平台：Windows Standalone
// 4.2 服务器端
// 实现方式 1：.NET 控制台 + HttpListener / ASP.NET Minimal API（推荐）

// 使用 .NET 6+ 控制台项目：
// 负责 HTTP 监听与路由；
// 使用同一套 C# 数据结构（共享类库）读写 meta.json；
// 好处：
// 脱离 Unity，部署简单高效；
// 更适合作为后台服务长期运行；
// 多线程和并发控制成熟。
// 实现方式 2：Unity 作为服务器

// 使用 Unity 工程 + HttpListener 或内嵌 WebServer 处理 API；
// 相同 C# 数据结构，可与客户端共享大量代码；
// 对团队完全 Unity 开发背景较友好，但长期作为服务进程不是最优。
// 可以先用方式 1 做一个轻量 Web API 服务器，客户端继续用 Unity 编；
// 服务器和客户端共享数据模型 DLL（如 AssetLibrary.Core）。

// 4.3 数据格式
// 元数据、配置、API 请求/响应：JSON（Newtonsoft.Json 或 System.Text.Json）。
// 文件和缩略图：二进制，通过 HTTP 流式传输。
// 5. 开发阶段规划（含局域网部分）
// 在之前单机步骤基础上，加入服务器建设步骤。

// 阶段实现
// 阶段 1：本地 Library + 客户端基础 UI（1–2 周）
// 在客户端实现：
// LibraryManager、AssetMetaData 等核心数据结构；
// 本地 LibraryRoot 的扫描、导入、预览（单机模式）；
// 基础 UI：分类、列表、详情、简单上传。
// 目的：先把功能在“本地模式”跑通，避免一开始就纠缠网络。
// 阶段 2：抽象出“数据访问层”接口（0.5–1 周）
// 定义接口 IAssetRepository（或类似）：
// GetAssets(...)
// GetAssetDetail(id)
// CreateAsset(meta + file)
// UpdateAsset(...)
// DeleteAsset(...)
// 提供两个实现：
// LocalAssetRepository（直接使用本地 LibraryManager）；
// RemoteAssetRepository（通过 HTTP 调用服务器）。
// 客户端 UI 只面向接口编写，这样切换“本地/远程模式”只需替换实现。

// 阶段 3：服务器端基本 API（1–2 周）
// 用 .NET/Unity 实现基础 REST API：
// 资源列表、详情、文件下载；
// 上传资源（新建）；
// 重用/移植客户端的 LibraryManager 逻辑到服务器端工程；
// 实现中央 LibraryRoot 目录结构和 meta 读写。
// 阶段 4：客户端接入服务器（1 周）
// 实现客户端 NetworkManager 和 RemoteAssetRepository：
// 提供配置界面输入服务器地址；
// 实现基础的 HTTP 通信；
// UI 中添加“连接服务器/断开连接”的功能；
// 验证：多台客户端同时连接服务器，能看到同一批资源。
// 阶段 5：完善权限、版本、重复检测（1–2 周）
// 在服务器添加 Token 校验、管理员/普通用户权限；
// 增加版本管理 API、重复检测逻辑；
// 客户端增加版本查看与回退、重复提示处理。
// 阶段 6：打磨与优化（1–2 周）
// 缓存缩略图和模型文件；
// 上传/下载进度条；
// 大库性能优化与 UI 流程优化。


